# Java Fundamentals: Collections

I gathered all infirmation that is new for me from the following Pluralsight course: https://app.pluralsight.com/library/courses/java-fundamentals-collections/table-of-contents

# Defining and iterating collections

- all Java collections inerfaces extend `java.util.Collection`
  - `List`: have order and indexing
  - `Set` - `SortedSet`: have distinct elements
  - `Queue` - `Deque` (double ended queue - stack): preserve the order in which elements have been added
- `Map` - `SortedMap`: contain key-value elements

- there are often more than one implementation for an interface:
  - a LinkedList is very efficient for inserting new elements
  - an ArrayList is very efficient for accessing inserted elements

- implementations
  - `List` (`ArrayList` & `LinkedList`)
  - `Set` (`HashSet`) - `SortedSet` (`TreeSet`)
  - `Queue` (`PriorityQueue`) - `Deque` (`LinkedList` `ArrayDeque`)
  - `Map` (`HashMap`) - `SortedMap` (`TreeMap`)

## Iterators

- the **diamond** operator introduced in Java 7, the generic type parameter will be infered from the context:

```java
Collection<Product> products = new ArrayList<>();
```

- with iterators you can interate over a collection and remove elements from the collection:

```java

for (Product product: products) {
  if (product.getWeight() > 10) {
    products.remove(product);
  }
}
```

NOTE: Useful library http://hamcrest.org/JavaHamcrest/.


# Lists

- ArrayList
- LinkedList

# Sets

## HashSet

### The equals()/hashCode() contract

If two objects are equal is important that they have the same hash-code:

```java
// if
obj.equals(other);

// than
obj.hasCode() == other.hashCode();
```

The correct hashCode implementation is to combine the hashCode information from each other field:
- for objects: result = 31 * result + obj.hashCode() // it is impotant to use a prime number in order to reduce collisions
- for arrays:  Arrays.hashCode()
- for longs: (l ^ (l >>> 32))
- for floats: Float.floatToIntBits(f)

NOTE: 
- **In most of the cases the IDSs are able to generate both the equals() and the hashCode() methods.**
- **The rules above are important only to be able to understand other people's code.**
- **Java 7 introduced a class calles Objects**:
  - use Objects.hash(...)
  - use Objects.equals(...)

## TreeSet

- based upon a TreeMap
	- uses a binary tree with required sort order
- keeps elements in the given order
	- see SortedSet and NavigableSet
- **when instantiating a `TreeSet` is important to either:**
  - **put objects that implement the comparator interface**
  - **or to provide the constructor with a comparator**

## EnumSet

- is a specialized data structure 
	- allows to store only enum objects
- use when sorting sets of enums